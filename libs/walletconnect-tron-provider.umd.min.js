!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).WalletConnectTronProvider=e()}(this,(function(){"use strict";class t{constructor(t={}){this.projectId=t.projectId,this.chains=t.chains||[195],this.rpcMap=t.rpcMap||{195:"https://api.trongrid.io"},this.showQrModal=void 0===t.showQrModal||t.showQrModal,this.connector=null,this.tronWeb=null,this._init()}async _init(){if(!this.projectId)throw new Error("projectId is required");const t=await import("https://unpkg.com/@walletconnect/core@2.10.0/dist/umd/index.min.js");this.connector=t.Core.default.init({projectId:this.projectId,metadata:{name:"Tron WalletConnect Provider",description:"Tron WalletConnect Provider",url:"https://tron.network",icons:["https://tron.network/favicon.ico"]}}),await this.connector.connect({requiredNamespaces:{tron:{chains:this.chains.map((t)=>`tron:${t}`),methods:["tron_signTransaction","tron_signMessage","tron_signTypedData"],events:["txHash"]}}}),this._setupListeners(),this.tronWeb=this._createTronWeb()}._setupListeners(){this.connector.on("connect",(t)=>{console.log("WalletConnect connected:",t),this.emit("connect",t)}),this.connector.on("disconnect",(t)=>{console.log("WalletConnect disconnected:",t),this.emit("disconnect",t)}),this.connector.on("session_update",(t)=>{console.log("WalletConnect session updated:",t),this.emit("session_update",t)})}._createTronWeb(){const t=this;return new TronWeb({fullHost:this.rpcMap[this.chains[0]],provider:{send:function(e,n){return new Promise((function(r,o){const i=JSON.parse(e);switch(i.method){case"eth_sendTransaction":t._signTransaction(i.params[0]).then((e)=>r({jsonrpc:"2.0",id:i.id,result:e})).catch((e)=>o(e));break;case"personal_sign":t._signMessage(i.params[1],i.params[0]).then((e)=>r({jsonrpc:"2.0",id:i.id,result:e})).catch((e)=>o(e));break;case"eth_signTypedData_v4":t._signTypedData(i.params[1],i.params[0]).then((e)=>r({jsonrpc:"2.0",id:i.id,result:e})).catch((e)=>o(e));break;default:fetch(t.rpcMap[t.chains[0]],{method:"POST",headers:{"Content-Type":"application/json"},body:e}).then((function(t){return t.json()})).then((function(e){r(e)})).catch((function(e){o(e)}))}}))},request:function(e){return new Promise((function(n,r){switch(e.method){case"eth_accounts":t._getAccounts().then((t)=>n(t)).catch((t)=>r(t));break;case"eth_signTransaction":t._signTransaction(e.params[0]).then((t)=>n(t)).catch((t)=>r(t));break;case"personal_sign":t._signMessage(e.params[1],e.params[0]).then((t)=>n(t)).catch((t)=>r(t));break;case"eth_signTypedData_v4":t._signTypedData(e.params[1],e.params[0]).then((t)=>n(t)).catch((t)=>r(t));break;default:r(new Error(`Unsupported method: ${e.method}`))}}))}})}async _getAccounts(){const t=this.connector.session.namespaces.tron.accounts[0];return[t.split(":")[2]]}async _signTransaction(t){const e={from:t.from,to:t.to,value:t.value||"0x0",data:t.data||"0x0",gas:t.gas||"0x1e240",gasPrice:t.gasPrice||"0x0",nonce:t.nonce};return this.connector.request({method:"tron_signTransaction",params:[e]})}async _signMessage(t,e){return this.connector.request({method:"tron_signMessage",params:[e,t]})}async _signTypedData(t,e){return this.connector.request({method:"tron_signTypedData",params:[e,t]})}async connect(){return this.connector.connect()}async disconnect(){return this.connector.disconnect()}on(t,e){this.connector.on(t,e)}off(t,e){this.connector.off(t,e)}}return t}));